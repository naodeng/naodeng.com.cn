<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>UI 测试最佳实践的测试策略（二）：什么样的测试策略才更合理 | 软件测试同学</title>
<meta name=keywords content><meta name=description content="这篇博文深入探讨 UI 测试最佳实践的测试策略（二），着重介绍了更为合理的测试策略。从避免追求完美主义、选择参考浏览器、发现 Bug 时的处理方式，到在修复之前编写测试、单个长的端到端测试与多个小的独立测试的选择，全面阐述了什么样的测试策略更为合理。无论是初学者还是经验丰富的测试专业人员，这篇博文都将为您提供实用的指导，帮助您制定更明智、高效的 UI 测试策略。点击链接，探索更合理的 UI 测试方法！"><meta name=author content="nao.deng"><link rel=canonical href=https://naodeng.com.cn/zh/posts/ui-automation-testing/ui-testing-best-practice-testing-strategy-2-more-reasonable-testing-strategy-for-ui-testing/><meta name=google-site-verification content="google5e9a7c9479924ed2"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://naodeng.com.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://naodeng.com.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://naodeng.com.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://naodeng.com.cn/apple-touch-icon.png><link rel=mask-icon href=https://naodeng.com.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://naodeng.com.cn/zh/posts/ui-automation-testing/ui-testing-best-practice-testing-strategy-2-more-reasonable-testing-strategy-for-ui-testing/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta name=baidu-site-verification content="codeva-2siuZUJUWf"><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?93a34d905469b810e5bae990720e7139",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script defer data-website-id=b3b285c9-3c35-4398-9252-91bb70560b84 src=https://naodeng-umami.vercel.app/hugo.js></script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "baa460bb003847e184ad7cbf459449e9"}'></script><meta http-equiv=Content-Type content="text/html;charset=gb2312"><meta name=sogou_site_verification content="iwkYDJrzfK"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7249159446737834" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-JBX883ZDJJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JBX883ZDJJ",{anonymize_ip:!1})}</script><meta property="og:title" content="UI 测试最佳实践的测试策略（二）：什么样的测试策略才更合理"><meta property="og:description" content="这篇博文深入探讨 UI 测试最佳实践的测试策略（二），着重介绍了更为合理的测试策略。从避免追求完美主义、选择参考浏览器、发现 Bug 时的处理方式，到在修复之前编写测试、单个长的端到端测试与多个小的独立测试的选择，全面阐述了什么样的测试策略更为合理。无论是初学者还是经验丰富的测试专业人员，这篇博文都将为您提供实用的指导，帮助您制定更明智、高效的 UI 测试策略。点击链接，探索更合理的 UI 测试方法！"><meta property="og:type" content="article"><meta property="og:url" content="https://naodeng.com.cn/zh/posts/ui-automation-testing/ui-testing-best-practice-testing-strategy-2-more-reasonable-testing-strategy-for-ui-testing/"><meta property="og:image" content="https://naodeng.com.cn/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-10T17:05:44+08:00"><meta property="article:modified_time" content="2024-01-10T17:05:44+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://naodeng.com.cn/papermod-cover.png"><meta name=twitter:title content="UI 测试最佳实践的测试策略（二）：什么样的测试策略才更合理"><meta name=twitter:description content="这篇博文深入探讨 UI 测试最佳实践的测试策略（二），着重介绍了更为合理的测试策略。从避免追求完美主义、选择参考浏览器、发现 Bug 时的处理方式，到在修复之前编写测试、单个长的端到端测试与多个小的独立测试的选择，全面阐述了什么样的测试策略更为合理。无论是初学者还是经验丰富的测试专业人员，这篇博文都将为您提供实用的指导，帮助您制定更明智、高效的 UI 测试策略。点击链接，探索更合理的 UI 测试方法！"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://naodeng.com.cn/zh/posts/"},{"@type":"ListItem","position":2,"name":"UI 测试最佳实践的测试策略（二）：什么样的测试策略才更合理","item":"https://naodeng.com.cn/zh/posts/ui-automation-testing/ui-testing-best-practice-testing-strategy-2-more-reasonable-testing-strategy-for-ui-testing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"UI 测试最佳实践的测试策略（二）：什么样的测试策略才更合理","name":"UI 测试最佳实践的测试策略（二）：什么样的测试策略才更合理","description":"这篇博文深入探讨 UI 测试最佳实践的测试策略（二），着重介绍了更为合理的测试策略。从避免追求完美主义、选择参考浏览器、发现 Bug 时的处理方式，到在修复之前编写测试、单个长的端到端测试与多个小的独立测试的选择，全面阐述了什么样的测试策略更为合理。无论是初学者还是经验丰富的测试专业人员，这篇博文都将为您提供实用的指导，帮助您制定更明智、高效的 UI 测试策略。点击链接，探索更合理的 UI 测试方法！","keywords":[],"articleBody":"文章由 UI 测试最佳实践项目 内容翻译而来，大家有条件的话可以去 UI 测试最佳实践项目阅读原文。\n什么样的测试策略才更合理 上一篇文章讲到了不同的测试类型，以及它们的优缺点。在这篇文章中，我们将深入探讨什么样的测试策略才更为合理。 会从在开始阶段，避免追求完美主义，选择一个参考浏览器，发现了 bug？先编写测试，然后再着手修复，和单个长的端到端测试还是多个小的独立测试？等方面阐述了什么样的测试策略才更合理\n在开始阶段，避免追求完美主义 测试真的改变了你的工作方式，但就像所有事情一样，需要一些经验才能真正发挥其威力。在一开始，务必避免完美主义的陷阱。为什么呢？\n测试本质上就是小程序。完美主义可能会导致你在了解如何处理不同的测试上下文之前编写非常复杂的测试。\n复杂的测试是个大敌人，因为调试失败的测试比调试失败的应用程序更加困难。而且复杂的测试让你失去了测试实践本身的优势，浪费了很多时间，最终不可避免地会让你放弃。如果你有这样的经历，不要气馁，对很多测试初学者来说都是一样的（对我来说也是，这就是我开始写这个 repo 的原因 😊），不要害怕向同事或其他开发人员寻求帮助。\n误报：完美主义导致很多误报。误报是指应用程序按预期工作，但测试失败的情况。\n误报在一开始确实让人泄气，因为你开始写测试是为了有一个盟友来检查应用程序状态… 但最终你却得到了另一个需要维护的应用程序，而测试并没有提供任何帮助。如果你发现自己在与误报作斗争，请停下来，重新学习，并寻求帮助！\n测试的实用性：成功的测试在失败时直接指向问题。正确的断言和确定性事件使你的测试强大而且非常重要的是，它们在失败时是有用的。相反，过多的断言和检查可能会使你的测试因为无用而变得脆弱。\n所谓完美主义是指检查每一个前端细节。在开始时，你的有限的测试经验不允许你有针对性地测试所有的交互。开始时，测试一些简单的事情，比如\n页面是否正确加载？ 菜单按钮是否正常工作？ 用户是否能够填写表单并成功跳转到感谢页面？ 而在开始阶段，不要过于关注测试一些诸如\n条件数据加载 复杂的表单规则 无控制的（第三方）集成 元素选择器 等复杂的交互。 为了避免陷入完美主义的陷阱，初学者的待办事项清单可以是：\n选择最简单的测试对象（对用户有用的东西）。 从用户的角度考虑。记住用户关心内容和功能，而不关心选择器和内部应用程序状态。 编写你的测试。 运行测试多次以确保它的稳定性。 当测试成功时，在前端应用程序中插入一个导致它失败的错误，然后检查测试是否失败。然后移除你故意插入的错误。 以无头和非无头模式运行测试。 根据你的经验（也问问同事），思考从你测试的内容的角度看，可能导致前端应用程序失败的原因是什么。 模拟不同的前端故障（关闭服务器、插入其他错误）并检查测试是否提供足够的反馈，以了解哪里失败了。 仅对两三种故障进行测试，记住你有限的经验可能导致你测试错误的东西。 然后，转移到另一个测试对象并重复所有先前的步骤。 软件测试是一场奇妙的旅程，这个 repo 的目标是帮助你避免最常见的陷阱。\n建议的流程只是可能方法之一。我知道一切都是主观的，请为每个建议提出请求以进行改进！\n选择一个参考浏览器 每个人都关心跨浏览器测试。我们通常习惯在每个浏览器上手动测试所有内容，因为我们知道，不同浏览器之间存在许多差异。当我们开始评估合适的测试工具时，跨浏览器测试是一个重要的话题，也是你在考虑时可能首先想到的。但是不要担心：首先从功能测试和视觉测试分离开始，这是正确评估跨浏览器支持需求（也是选择正确测试工具的第一步）。视觉测试可以集成到每个测试工具中，感谢诸如 Applitools 和 Percy 这样的服务。\n换句话说，不要仅仅基于跨浏览器支持来选择测试工具。以下是一些建议：\nSelenium 和 Puppeteer 是通用的自动化工具。它们可以用作测试工具（有许多插件和模块可帮助你实现），但它们并非专为测试而设计，因此它们缺少一些集成实用工具，这可能使测试编写更加简便。\n只考虑 Cypress、Playwright 和 TestCafé，因为它们是专为简化 UI 测试过程而创建的工具。这些工具自动处理一半的最佳实践，而在测试中的一些方面，它们可能更符合你的需求。在 UI 测试方面，由于其\n困难性，花些时间试验这些工具是值得的。\n仔细思考你需要测试什么。如果你需要测试特定的移动能力，请选择 TestCafé，但如果你只需要测试表单和按钮是否正常工作，你在选择上就更加灵活。\n查看 Cypress Test Runner，这是使 Cypress 异于常人的工具，对于测试开发过程中非常有帮助。\n研究 Playwright 在调试方面的优势。Playwright 非常快速稳定，最近其开发体验有了很大改进。\n跨浏览器测试通常涉及到视觉测试（CSS 浏览器差异），但这与功能测试不同。视觉测试得益于许多专用插件和工具的支持。详细了解 视觉测试对应的章节 Applitools，其中我们讨论了一些专用产品，这些产品可以与几乎所有测试工具集成，通过将被测试页面的快照上传到其服务器并进行呈现来进行工作。\n你还可以在 等待，不是休眠 章节中了解各种测试工具之间的一些差异。\n发现了 bug？先编写测试，然后再着手修复 所以，当你在前端应用程序中发现错误并已经进行了调试时，你可以系统地复现它，准备好修复它。以测试为导向的思维必须经历以下步骤：\n确定预期的行为。 编写一个测试，旨在以正确的方式使用前端应用程序。 测试必须失败，因为错误不允许用户完成任务。 修复错误。 检查测试现在是否通过。 为什么要采用这种方法？为什么要编写测试呢？我知道直接修复错误可能看起来更快，但请考虑以下几点：\n通常情况下，你的测试工具比你更快地达到显示错误的应用程序状态（参见使用测试工具作为主要开发工具 章节）。\n有时你认为你能够系统地复现错误，但这并不总是正确的。编写一个揭示错误的测试可以确保你百分之百确定错误是可重现的，排除了许多偏差变量，如现有的会话、缓存、服务工作者、浏览器扩展、浏览器版本等，这些可能会影响你的信心。有时你可能会发现你并没有完全正确地识别错误。\n与此同时，当测试通过了你的修复时，你确实知道你的解决方\n案按预期工作。可能影响错误识别过程的相同变量可能会影响工作效果的虚假感觉。\n有了测试，错误就可以永远修复了！ 测试将被执行成千上万次，让你对错误修复感到百分之百的信心。\n成功的测试可以作为你所做工作的验证轨迹。\n最后但同样重要的是：确保你编写的测试一开始是失败的！而且它之所以失败是因为有错误！\n测试不仅仅是为了重现错误并在视觉上检查它，而是必须在修复错误后获得积极的反馈。与错误相关的测试如果一开始就没有失败，那真的非常危险，因为你可能认为你做得很好，而实际上你从一开始就没有完全正确地重现错误。\n作为一般规则：破碎的流程必须有一个破碎的测试，一个成功的测试必须与一个正常工作的应用程序相关联。\n单个长的端到端测试还是多个小的独立测试？ 在讨论对 CRUD 应用进行测试时，我们应该如何组织“创建”、“修改”和“删除”端到端（E2E）测试呢？\n完整的选项列表如下：\n有三个小的 E2E 测试，依赖于执行顺序（测试 B 假设测试 A 已运行）- 这是唯一的不良解决方案，我将解释原因。 有三个小的 E2E 测试，独立于执行顺序（测试 B 不受测试 A 是否运行的影响）- 从理论上讲，是最好的解决方案。但仍然需要大量样板代码，而且为了快速执行。 有一个执行所有操作的扩展 E2E 测试 - 对于本文介绍的案例来说，这是一个很好的折中方案。 这取决于情况，我提到的大多数问题与 E2E 测试的隐含问题有关，这是我们应该尽量减少这类测试的强烈信号。作为前端工程师，我更喜欢投资时间编写无需服务器的测试，而不是 E2E 测试。继续阅读，你将了解原因。\n1 - 有三个小的 E2E 测试，依赖于执行顺序（测试 B 假设测试 A 已运行） 测试流程如下：\n开始（应用程序状态为空） 测试 1: 创建实体 测试 2: 修改实体 测试 3: 删除实体 结束（应用程序状态为空） 在这种情况下，这些测试不是独立的，而是依赖于执行顺序。为了测试 CRUD 流程，有三个主要测试：“创建实体”、“修改实体”、“删除实体”。第二个测试（“修改实体”）假设在其启动时应用程序状态是正确的，因为它在 “创建实体” 之后运行。“删除实体” 也必须在 “修改实体” 之后运行，依此类推。\n将多个测试耦合在一起是一种反模式，原因如下：\n误报：一旦一个测试失败，后续测试会连续失败。 难以调试：由于不确定性较高，理解失败的根本原因更加复杂。测试失败是因为代码本身失败？还是因为先前测试的状态发生了变化？然后，当一个测试失败时，你必须调试两个测试。 难以调试（再次）：开发人员会浪费大量时间，因为他们无法运行单个测试，也无法使用 skip 和 only 仅运行其中一部分测试。 难以重构：测试无法移动到其他位置。如果测试代码变得太长、太复杂等，你无法将其移动到专用文件/目录中，因为它依赖于先前的测试。 难以阅读：读者无法知道一个测试的作用，因为他们还必须了解先前的测试。你必须阅读两个测试，而不是一个，这是不好的。 我不建议以这种方式编写耦合的测试，但我想包含它们以确保您明白原因。\n2 - 设计三个小型端到端（E2E）测试，使其独立于执行顺序 为了确保每个测试的独立性，每个测试在运行前都应该创建所需的应用程序状态，然后在完成后进行清理。相较于原有的顺序（创建-\u003e修改-\u003e删除），前文提到的流程应该调整如下（斜体 表示与原有流程相比的新步骤）：\n开始（应用程序状态为空） 测试 1：创建实体 之前：加载页面（应用程序状态为空） 创建实体 之后：删除实体（应用程序状态为空） 测试 2：修改实体 之前：通过 API 创建实体 之前：加载页面（应用程序状态为空） 修改实体 之后：通过 API 删除实体（应用程序状态为空） 测试 3：删除实体 之前：通过 API 创建实体 之前：加载页面（应用程序状态为空） 删除实体 之后：删除操作（应用程序状态为空） 结束（应用程序状态为空） 通过这种方式，每个测试都是相互独立的。需要注意的是，之前和之后的操作直接通过调用服务器 API 完成，因为通过 UI 完成这些操作将会很慢。然而，这种方法的问题在于测试变得更加耗时，因为每个测试都需要创建实体，并且每个测试都需要访问页面。当应用程序加载需要花费 10 秒钟时（Hasura 的控制台最初的情况），重新加载应用程序将成为一个问题。\n为了确保测试既独立又高效，我们需要进一步改进上述流程：\n充分利用前一个测试的应用状态。 同时，如果尚未运行测试，还需要创建所需的应用状态。 具体来说，流程如下（与前一章节相比，斜体表示新步骤）：\n开始（应用状态为空）\n测试 1： 创建实体\n之前：实体 是否存在？ 否：没问题！ 是：通过 API 删除实体 之前：加载页面（应用状态为空） 创建实体 测试 2： 修改实体\n之前：实体 是否存在？ 是：没问题！ 否：通过 API 创建实体 之前：实体 是否已包含测试即将进行的更改？ 是：没问题！ 否：通过 API 修改实体 之前：我们是否已经在正确的页面上？ 是：没问题！ 否：加载页面 修改实体 测试 3： 删除实体\n之前：实体是否存在？ 是：没问题！ 否：通过 API 创建实体 之前：我们是否已经在正确的页面上？ 是：没问题！ 否：加载页面 删除实体\n结束（应用状态为空）\n现在，如果你一次运行所有测试，每个测试都会利用之前测试的应用状态。如果只运行“修改实体”测试，它会创建所需的一切，然后运行测试本身。\n现在我们既有测试的独立性又有测试的性能！很不错！\n嗯… 你是否注意到我们需要编写大量代码？cypress-data-session 插件很方便，但存在两个问题：\n有很多与 cypress-data-session 相关的样板代码 在 E2E 测试中，必须维护许多可能与主应用程序中使用的 API 调用不同步的 API 调用。 这是一个与 cypress-data-session 相关的样板代码示例（来自 Hasura Console 代码库）。\nimport { readMetadata } from '../services/readMetadata'; import { deleteHakunaMatataPermission } from '../services/deleteHakunaMatataPermission'; /** * Ensure the Action does not have the Permission. * * ATTENTION: if you get the \"setup function changed for session...\" error, simply close the * Cypress-controlled browser and re-launch the test file. */ export function hakunaMatataPermissionMustNotExist( settingUpApplicationState = true ) { cy.dataSession({ name: 'hakunaMatataPermissionMustNotExist', // Without it, cy.dataSession run the setup function also the very first time, trying to // delete a Permission that does not exist init: () =\u003e true, // Check if the Permission exists validate: () =\u003e { Cypress.log({ message: '**--- Action check: start**' }); return readMetadata().then(response =\u003e { const loginAction = response.body.actions?.find( action =\u003e action.name === 'login' ); if (!loginAction || !loginAction.permissions) return true; const permission = loginAction.permissions.find( permission =\u003e permission.role === 'hakuna_matata' ); // Returns true if the permission does not exist return !permission; }); }, preSetup: () =\u003e Cypress.log({ message: '**--- The permission must be deleted**' }), // Delete the Permission setup: () =\u003e { deleteHakunaMatataPermission(); if (settingUpApplicationState) { // Ensure the UI read the latest data if it were previously loaded cy.reload(); } }, }); } 以下是用于创建实体的 API 调用示例（来自 Hasura Console 代码库）。\n/** * Create the Action straight on the server. */ export function createLoginAction() { Cypress.log({ message: '**--- Action creation: start**' }); cy.request('POST', 'http://localhost:8080/v1/metadata', { type: 'bulk', source: 'default', args: [ { type: 'set_custom_types', args: { scalars: [], input_objects: [ { name: 'SampleInput', fields: [ { name: 'username', type: 'String!' }, { name: 'password', type: 'String!' }, ], }, ], objects: [ { name: 'SampleOutput', fields: [{ name: 'accessToken', type: 'String!' }], }, { name: 'LoginResponse', description: null, fields: [ { name: 'accessToken', type: 'String!', description: null, }, ], }, { name: 'AddResult', fields: [{ name: 'sum', type: 'Int' }], }, ], enums: [], }, }, { type: 'create_action', args: { name: 'login', definition: { arguments: [ { name: 'username', type: 'String!', description: null, }, { name: 'password', type: 'String!', description: null, }, ], kind: 'synchronous', output_type: 'LoginResponse', handler: 'https://hasura-actions-demo.glitch.me/login', type: 'mutation', headers: [], timeout: 25, request_transform: null, }, comment: null, }, }, ], }).then(() =\u003e Cypress.log({ message: '**--- Action creation: end**' })); } 因此，拥有独立的测试是至关重要的，但也伴随着一些成本。\n这就是为什么，针对这个具体问题，我选择了最后一种选择…\n3 - 进行一次全面的端到端测试 优点：可以减少很多样板文件。\n缺点：与测试一起工作变得更慢了（你不能再仅运行第三个测试了）\n与我们需要编写的样板和需要维护的代码相比，将它们统一起来是值得的。毕竟，我正在处理的特定 CRUD 流程大约需要 20 秒。\n开始 (应用程序状态为空) 测试：CRUD 之前*：如果存在实体，则删除它（应用程序状态为空）* 之前*：加载页面* 创建实体 修改实体 删除实体 之后*：如果存在实体，则删除它（应用程序状态为空）* 结束 (应用程序状态为空) 同时，这也使得 cypress-data-session 变得无用。因此，少了一个需要保持更新的依赖。\n结论 处理端到端测试很困难。处理真实数据、清除真实应用程序状态等都是有成本的。我知道端到端测试是唯一能够提供完整信心的测试，但作为一名前端工程师（请记住，我不是 QA 工程师），我更愿意使用无需服务器的测试。\n相关章节 🔗 从金字塔的顶端着手构建测试！ 🔗 把你的测试工具当作主要的开发工具来使用 由 NoriSte 在 dev.to上进行了跨发表。\n参考资料 UI 测试最佳实践项目:https://github.com/NoriSte/ui-testing-best-practices UI 测试最佳实践项目中文翻译:https://github.com/naodeng/ui-testing-best-practices 欢迎关注软件测试同学的公众号“软件测试同学”，原创 QA 技术文章第一时间推送。\n","wordCount":"686","inLanguage":"zh","datePublished":"2024-01-10T17:05:44+08:00","dateModified":"2024-01-10T17:05:44+08:00","author":{"@type":"Person","name":"nao.deng"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://naodeng.com.cn/zh/posts/ui-automation-testing/ui-testing-best-practice-testing-strategy-2-more-reasonable-testing-strategy-for-ui-testing/"},"publisher":{"@type":"Organization","name":"软件测试同学","logo":{"@type":"ImageObject","url":"https://naodeng.com.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://naodeng.com.cn/zh/ accesskey=h title="软件测试同学 (Alt + H)">软件测试同学</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://naodeng.com.cn/ title=🇬🇧English aria-label=🇬🇧English>🇬🇧English</a></li></ul></div></div><ul id=menu><li><a href=https://naodeng.com.cn/zh/archives/ title=归档><span>归档</span></a></li><li><a href=https://naodeng.com.cn/zh/zhcategories title=分类><span>分类</span></a></li><li><a href=https://naodeng.com.cn/zh/search/ title=搜索><span>搜索</span></a></li><li><a href=https://naodeng.com.cn/zh/zhtags title=标签><span>标签</span></a></li><li><a href=https://naodeng.com.cn/zh/zhseries title=系列><span>系列</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://naodeng.com.cn/zh/>主页</a>&nbsp;»&nbsp;<a href=https://naodeng.com.cn/zh/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">UI 测试最佳实践的测试策略（二）：什么样的测试策略才更合理</h1><div class=post-meta><span title='2024-01-10 17:05:44 +0800 +0800'>一月 10, 2024</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;686 字&nbsp;·&nbsp;nao.deng&nbsp;|&nbsp;<a href=https://github.com/naodeng/naodeng.com.cn/tree/main/content/posts/UI-Automation-Testing/UI-Testing-best-practice-testing-strategy-2-more-reasonable-testing-strategy-for-UI-testing.zh.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5%e6%89%8d%e6%9b%b4%e5%90%88%e7%90%86 aria-label=什么样的测试策略才更合理>什么样的测试策略才更合理</a><ul><li><a href=#%e5%9c%a8%e5%bc%80%e5%a7%8b%e9%98%b6%e6%ae%b5%e9%81%bf%e5%85%8d%e8%bf%bd%e6%b1%82%e5%ae%8c%e7%be%8e%e4%b8%bb%e4%b9%89 aria-label=在开始阶段，避免追求完美主义>在开始阶段，避免追求完美主义</a></li><li><a href=#%e9%80%89%e6%8b%a9%e4%b8%80%e4%b8%aa%e5%8f%82%e8%80%83%e6%b5%8f%e8%a7%88%e5%99%a8 aria-label=选择一个参考浏览器>选择一个参考浏览器</a></li><li><a href=#%e5%8f%91%e7%8e%b0%e4%ba%86-bug%e5%85%88%e7%bc%96%e5%86%99%e6%b5%8b%e8%af%95%e7%84%b6%e5%90%8e%e5%86%8d%e7%9d%80%e6%89%8b%e4%bf%ae%e5%a4%8d aria-label="发现了 bug？先编写测试，然后再着手修复">发现了 bug？先编写测试，然后再着手修复</a></li><li><a href=#%e5%8d%95%e4%b8%aa%e9%95%bf%e7%9a%84%e7%ab%af%e5%88%b0%e7%ab%af%e6%b5%8b%e8%af%95%e8%bf%98%e6%98%af%e5%a4%9a%e4%b8%aa%e5%b0%8f%e7%9a%84%e7%8b%ac%e7%ab%8b%e6%b5%8b%e8%af%95 aria-label=单个长的端到端测试还是多个小的独立测试？>单个长的端到端测试还是多个小的独立测试？</a><ul><li><a href=#1---%e6%9c%89%e4%b8%89%e4%b8%aa%e5%b0%8f%e7%9a%84-e2e-%e6%b5%8b%e8%af%95%e4%be%9d%e8%b5%96%e4%ba%8e%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f%e6%b5%8b%e8%af%95-b-%e5%81%87%e8%ae%be%e6%b5%8b%e8%af%95-a-%e5%b7%b2%e8%bf%90%e8%a1%8c aria-label="1 - 有三个小的 E2E 测试，依赖于执行顺序（测试 B 假设测试 A 已运行）">1 - 有三个小的 E2E 测试，依赖于执行顺序（测试 B 假设测试 A 已运行）</a></li><li><a href=#2---%e8%ae%be%e8%ae%a1%e4%b8%89%e4%b8%aa%e5%b0%8f%e5%9e%8b%e7%ab%af%e5%88%b0%e7%ab%afe2e%e6%b5%8b%e8%af%95%e4%bd%bf%e5%85%b6%e7%8b%ac%e7%ab%8b%e4%ba%8e%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f aria-label="2 - 设计三个小型端到端（E2E）测试，使其独立于执行顺序">2 - 设计三个小型端到端（E2E）测试，使其独立于执行顺序</a></li><li><a href=#3---%e8%bf%9b%e8%a1%8c%e4%b8%80%e6%ac%a1%e5%85%a8%e9%9d%a2%e7%9a%84%e7%ab%af%e5%88%b0%e7%ab%af%e6%b5%8b%e8%af%95 aria-label="3 - 进行一次全面的端到端测试">3 - 进行一次全面的端到端测试</a></li><li><a href=#%e7%bb%93%e8%ae%ba aria-label=结论>结论</a></li><li><a href=#%e7%9b%b8%e5%85%b3%e7%ab%a0%e8%8a%82 aria-label=相关章节>相关章节</a></li></ul></li></ul></li><li><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a></li></ul></div></details></div><div class=post-content><p>文章由 <a href=https://github.com/NoriSte/ui-testing-best-practices>UI 测试最佳实践项目</a> 内容翻译而来，大家有条件的话可以去 <a href=https://github.com/NoriSte/ui-testing-best-practices>UI 测试最佳实践项目</a>阅读原文。</p><h2 id=什么样的测试策略才更合理>什么样的测试策略才更合理<a hidden class=anchor aria-hidden=true href=#什么样的测试策略才更合理>#</a></h2><p>上一篇文章讲到了不同的测试类型，以及它们的优缺点。在这篇文章中，我们将深入探讨什么样的测试策略才更为合理。
会从在开始阶段，避免追求完美主义，选择一个参考浏览器，发现了 bug？先编写测试，然后再着手修复，和单个长的端到端测试还是多个小的独立测试？等方面阐述了什么样的测试策略才更合理</p><h3 id=在开始阶段避免追求完美主义>在开始阶段，避免追求完美主义<a hidden class=anchor aria-hidden=true href=#在开始阶段避免追求完美主义>#</a></h3><p>测试真的改变了你的工作方式，但就像所有事情一样，需要一些经验才能真正发挥其威力。在一开始，务必避免完美主义的陷阱。为什么呢？</p><ul><li><p>测试本质上就是小程序。完美主义可能会导致你在了解如何处理不同的测试上下文之前编写<strong>非常复杂的测试</strong>。</p><p>复杂的测试是个大敌人，因为调试失败的测试比调试失败的应用程序更加困难。而且复杂的测试让你失去了测试实践本身的优势，浪费了很多时间，最终不可避免地会让你放弃。<strong>如果你有这样的经历，不要气馁</strong>，对很多测试初学者来说都是一样的（对我来说也是，这就是我开始写这个 repo 的原因 😊），不要害怕向同事或其他开发人员寻求帮助。</p></li><li><p>误报：完美主义导致很多误报。误报是指应用程序按预期工作，但测试失败的情况。</p><p><strong>误报在一开始确实让人泄气</strong>，因为你开始写测试是为了有一个盟友来检查应用程序状态&mldr; 但最终你却得到了另一个需要维护的应用程序，而测试并没有提供任何帮助。如果你发现自己在与误报作斗争，请停下来，重新学习，并寻求帮助！</p></li><li><p>测试的实用性：成功的测试在失败时直接指向问题。正确的断言和<a href=/sections/generic-best-practices/await-dont-sleep.zh.md>确定性事件</a>使你的测试强大而且非常重要的是，它们在失败时是有用的。相反，过多的断言和检查可能会使你的测试因为无用而变得脆弱。</p></li></ul><p>所谓完美主义是指检查每一个前端细节。在开始时，你的有限的测试经验不允许你有针对性地测试所有的交互。开始时，测试一些简单的事情，比如</p><ul><li>页面是否正确加载？</li><li>菜单按钮是否正常工作？</li><li>用户是否能够填写表单并成功跳转到感谢页面？</li></ul><p>而在开始阶段，不要过于关注测试一些诸如</p><ul><li>条件数据加载</li><li>复杂的表单规则</li><li>无控制的（第三方）集成</li><li>元素选择器 等复杂的交互。</li></ul><br><p>为了避免陷入完美主义的陷阱，初学者的待办事项清单可以是：</p><ol><li>选择最简单的测试对象（对用户有用的东西）。</li><li>从用户的角度考虑。记住<strong>用户关心内容和功能</strong>，而不关心选择器和内部应用程序状态。</li><li>编写你的测试。</li><li>运行测试多次以确保它的稳定性。</li><li>当测试成功时，在前端应用程序中插入一个导致它失败的错误，然后检查测试是否失败。然后移除你故意插入的错误。</li><li>以无头和非无头模式运行测试。</li><li>根据你的经验（也问问同事），思考从你测试的内容的角度看，可能导致前端应用程序失败的原因是什么。</li><li>模拟不同的前端故障（关闭服务器、插入其他错误）并检查测试是否提供足够的反馈，以了解哪里失败了。</li><li>仅对两三种故障进行测试，记住你有限的经验可能导致你测试错误的东西。</li><li>然后，转移到另一个测试对象并重复所有先前的步骤。</li></ol><p>软件测试是一场奇妙的旅程，这个 repo 的目标是帮助你避免最常见的陷阱。</p><p>建议的流程只是可能方法之一。我知道一切都是主观的，请为每个建议提出请求以进行改进！</p><h3 id=选择一个参考浏览器>选择一个参考浏览器<a hidden class=anchor aria-hidden=true href=#选择一个参考浏览器>#</a></h3><p>每个人都关心跨浏览器测试。我们通常习惯在每个浏览器上手动测试所有内容，因为我们知道，不同浏览器之间存在许多差异。当我们开始评估合适的测试工具时，跨浏览器测试是一个重要的话题，也是你在考虑时可能首先想到的。但是不要担心：首先从功能测试和视觉测试分离开始，这是正确评估跨浏览器支持需求（也是选择正确测试工具的第一步）。视觉测试可以集成到每个测试工具中，感谢诸如 Applitools 和 Percy 这样的服务。</p><p>换句话说，不要仅仅基于跨浏览器支持来选择测试工具。以下是一些建议：</p><ul><li><p><strong>Selenium 和 Puppeteer 是通用的自动化工具</strong>。它们可以用作测试工具（有许多插件和模块可帮助你实现），但它们并非专为测试而设计，因此它们缺少一些集成实用工具，这可能使测试编写更加简便。</p></li><li><p>只考虑 <strong>Cypress、Playwright 和 TestCafé</strong>，因为它们是专为<strong>简化 UI 测试过程</strong>而创建的工具。这些工具自动处理一半的最佳实践，而在测试中的一些方面，它们可能更符合你的需求。在 UI 测试方面，由于其</p></li></ul><p>困难性，花些时间试验这些工具是值得的。</p><ul><li><p>仔细思考你需要测试什么。如果你需要测试特定的移动能力，请选择 <a href=https://testcafe.devexpress.com>TestCafé</a>，但如果你只需要测试表单和按钮是否正常工作，你在选择上就更加灵活。</p></li><li><p>查看 <a href=https://docs.cypress.io/guides/core-concepts/test-runner.html#Command-Log>Cypress Test Runner</a>，这是使 Cypress 异于常人的工具，对于测试开发过程中非常有帮助。</p></li><li><p>研究 <a href=https://playwright.dev/docs/trace-viewer-intro>Playwright 在调试方面的优势</a>。Playwright 非常快速稳定，最近其开发体验有了很大改进。</p></li><li><p>跨浏览器测试通常涉及到视觉测试（CSS 浏览器差异），但这与功能测试不同。视觉测试得益于许多专用插件和工具的支持。详细了解 <a href=../tools/visual-regression-testing.zh.md>视觉测试对应的章节</a> <a href=https://applitools.com>Applitools</a>，其中我们讨论了一些专用产品，这些产品可以与几乎所有测试工具集成，通过将被测试页面的快照上传到其服务器并进行呈现来进行工作。</p></li></ul><p>你还可以在 <a href=/sections/generic-best-practices/await-dont-sleep.zh.md>等待，不是休眠</a> 章节中了解各种测试工具之间的一些差异。</p><h3 id=发现了-bug先编写测试然后再着手修复>发现了 bug？先编写测试，然后再着手修复<a hidden class=anchor aria-hidden=true href=#发现了-bug先编写测试然后再着手修复>#</a></h3><p>所以，当你在前端应用程序中发现错误并已经进行了调试时，你可以系统地复现它，准备好修复它。以测试为导向的思维必须经历以下步骤：</p><ol><li>确定预期的行为。</li><li>编写一个测试，旨在以正确的方式使用前端应用程序。</li><li>测试必须失败，因为错误不允许用户完成任务。</li><li>修复错误。</li><li>检查测试现在是否通过。</li></ol><p>为什么要采用这种方法？为什么要编写测试呢？我知道直接修复错误可能看起来更快，但请考虑以下几点：</p><ul><li><p>通常情况下，你的测试工具比你更快地达到显示错误的应用程序状态（参见<a href=/sections/generic-best-practices/use-your-testing-tool-as-your-primary-development-tool.zh.md>使用测试工具作为主要开发工具</a> 章节）。</p></li><li><p>有时你认为你能够系统地复现错误，但这并不总是正确的。编写一个揭示错误的测试可以确保你百分之百确定错误是可重现的，<strong>排除了许多偏差变量</strong>，如现有的会话、缓存、服务工作者、浏览器扩展、浏览器版本等，这些可能会影响你的信心。有时你可能会发现你并没有完全正确地识别错误。</p></li><li><p>与此同时，当测试通过了你的修复时，你确实知道你的解决方</p></li></ul><p>案按预期工作。可能影响错误识别过程的相同变量可能会影响工作效果的虚假感觉。</p><ul><li><p><strong>有了测试，错误就可以永远修复了！</strong> 测试将被执行成千上万次，让你对错误修复感到百分之百的信心。</p></li><li><p>成功的测试可以作为你所做工作的验证轨迹。</p></li></ul><p>最后但同样重要的是：确保你编写的测试一开始是失败的！而且它之所以失败是因为有错误！</p><br><p>测试不仅仅是为了重现错误并在视觉上检查它，而是必须在修复错误后获得积极的反馈。<strong>与错误相关的测试如果一开始就没有失败，那真的非常危险</strong>，因为你可能认为你做得很好，而实际上你从一开始就没有完全正确地重现错误。</p><p>作为一般规则：<strong>破碎的流程必须有一个破碎的测试</strong>，一个成功的测试必须与一个正常工作的应用程序相关联。</p><h3 id=单个长的端到端测试还是多个小的独立测试>单个长的端到端测试还是多个小的独立测试？<a hidden class=anchor aria-hidden=true href=#单个长的端到端测试还是多个小的独立测试>#</a></h3><p>在讨论对 CRUD 应用进行测试时，我们应该如何组织“创建”、“修改”和“删除”端到端（E2E）测试呢？</p><p>完整的选项列表如下：</p><ol><li><strong>有三个小的 E2E 测试，依赖于执行顺序</strong>（测试 B 假设测试 A 已运行）- 这是唯一的不良解决方案，我将解释原因。</li><li><strong>有三个小的 E2E 测试，独立于执行顺序</strong>（测试 B 不受测试 A 是否运行的影响）- 从理论上讲，是最好的解决方案。但仍然需要大量样板代码，而且为了快速执行。</li><li><strong>有一个执行所有操作的扩展 E2E 测试</strong> - 对于本文介绍的案例来说，这是一个很好的折中方案。</li></ol><p>这取决于情况，我提到的大多数问题与 E2E 测试的隐含问题有关，这是我们应该尽量减少这类测试的强烈信号。作为前端工程师，我更喜欢投资时间编写无需服务器的测试，而不是 E2E 测试。继续阅读，你将了解原因。</p><p><br><br></p><h4 id=1---有三个小的-e2e-测试依赖于执行顺序测试-b-假设测试-a-已运行>1 - 有三个小的 E2E 测试，依赖于执行顺序（测试 B 假设测试 A 已运行）<a hidden class=anchor aria-hidden=true href=#1---有三个小的-e2e-测试依赖于执行顺序测试-b-假设测试-a-已运行>#</a></h4><p>测试流程如下：</p><ol><li>开始（<em>应用程序状态为空</em>）</li><li>测试 1: 创建实体</li><li>测试 2: 修改实体</li><li>测试 3: 删除实体</li><li>结束（<em>应用程序状态为空</em>）</li></ol><p>在这种情况下，这些测试不是独立的，而是依赖于执行顺序。为了测试 CRUD 流程，有三个主要测试：&ldquo;创建实体&rdquo;、&ldquo;修改实体&rdquo;、&ldquo;删除实体&rdquo;。第二个测试（&ldquo;修改实体&rdquo;）假设在其启动时应用程序状态是正确的，因为它在 &ldquo;创建实体&rdquo; 之后运行。&ldquo;删除实体&rdquo; 也必须在 &ldquo;修改实体&rdquo; 之后运行，依此类推。</p><p>将多个测试耦合在一起是一种反模式，原因如下：</p><ul><li><strong>误报</strong>：一旦一个测试失败，后续测试会连续失败。</li><li><strong>难以调试</strong>：由于不确定性较高，理解失败的根本原因更加复杂。测试失败是因为代码本身失败？还是因为先前测试的状态发生了变化？然后，当一个测试失败时，你必须调试两个测试。</li><li><strong>难以调试</strong>（再次）：开发人员会浪费大量时间，因为他们无法运行单个测试，也无法使用 <code>skip</code> 和 <code>only</code> 仅运行其中一部分测试。</li><li><strong>难以重构</strong>：测试无法移动到其他位置。如果测试代码变得太长、太复杂等，你无法将其移动到专用文件/目录中，因为它依赖于先前的测试。</li><li><strong>难以阅读</strong>：读者无法知道一个测试的作用，因为他们还必须了解先前的测试。你必须阅读两个测试，而不是一个，这是不好的。</li></ul><p>我不建议以这种方式编写耦合的测试，但我想包含它们以确保您明白原因。</p><h4 id=2---设计三个小型端到端e2e测试使其独立于执行顺序>2 - 设计三个小型端到端（E2E）测试，使其独立于执行顺序<a hidden class=anchor aria-hidden=true href=#2---设计三个小型端到端e2e测试使其独立于执行顺序>#</a></h4><p>为了确保每个测试的独立性，每个测试在运行前都应该创建所需的应用程序状态，然后在完成后进行清理。相较于原有的顺序（创建->修改->删除），前文提到的流程应该调整如下（<em>斜体</em> 表示与原有流程相比的新步骤）：</p><ol><li><strong>开始</strong>（<em>应用程序状态为空</em>）</li><li><strong>测试 1：创建实体</strong><ol><li><em><strong>之前</strong></em>：加载页面（<em>应用程序状态为空</em>）</li><li>创建实体</li><li><em><strong>之后</strong></em>：删除<em>实体</em>（<em>应用程序状态为空</em>）</li></ol></li><li><strong>测试 2：修改实体</strong><ol><li><em><strong>之前</strong></em>：通过 API 创建<em>实体</em></li><li><em><strong>之前</strong></em>：加载页面（<em>应用程序状态为空</em>）</li><li>修改实体</li><li><em><strong>之后</strong></em>：通过 API 删除<em>实体</em>（<em>应用程序状态为空</em>）</li></ol></li><li><strong>测试 3：删除实体</strong><ol><li><em><strong>之前</strong></em>：通过 API 创建<em>实体</em></li><li><em><strong>之前</strong></em>：加载页面（<em>应用程序状态为空</em>）</li><li>删除实体</li><li><em><strong>之后</strong></em>：删除操作（<em>应用程序状态为空</em>）</li></ol></li><li><strong>结束</strong>（<em>应用程序状态为空</em>）</li></ol><p>通过这种方式，每个测试都是相互独立的。需要注意的是，之前和之后的操作直接通过调用服务器 API 完成，因为通过 UI 完成这些操作将会很慢。然而，这种方法的问题在于<strong>测试变得更加耗时</strong>，因为每个测试都需要创建实体，并且每个测试都需要访问页面。当应用程序加载需要花费 10 秒钟时（Hasura 的控制台最初的情况），重新加载应用程序将成为一个问题。</p><p>为了确保测试既独立又高效，我们需要进一步改进上述流程：</p><ul><li>充分利用前一个测试的应用状态。</li><li>同时，如果尚未运行测试，还需要创建所需的应用状态。</li></ul><p>具体来说，流程如下（与前一章节相比，<em>斜体</em>表示新步骤）：</p><ol><li><p><strong>开始</strong>（<em>应用状态为空</em>）</p></li><li><p><strong>测试 1：</strong> 创建实体</p><ol><li><em><strong>之前</strong></em>：<em>实体</em> 是否存在？<ol><li><em>否：没问题！</em></li><li><em>是：通过 API 删除实体</em></li></ol></li><li><em><strong>之前</strong></em>：加载页面（<em>应用状态为空</em>）</li><li>创建实体</li></ol></li><li><p><strong>测试 2：</strong> 修改实体</p><ol><li><em><strong>之前</strong></em>：<em>实体</em> 是否存在？<ol><li><em>是：没问题！</em></li><li><em>否：通过 API 创建实体</em></li></ol></li><li><em><strong>之前</strong></em>：<em>实体</em> 是否已包含测试即将进行的更改？<ol><li><em>是：没问题！</em></li><li><em>否：通过 API 修改实体</em></li></ol></li><li><em><strong>之前</strong></em>：我们是否已经在正确的页面上？<ol><li><em>是：没问题！</em></li><li><em>否：加载页面</em></li></ol></li><li>修改实体</li></ol></li><li><p><strong>测试 3：</strong> 删除实体</p><ol><li><em><strong>之前</strong></em>：实体是否存在？<ol><li><em>是：没问题！</em></li><li><em>否：通过 API 创建实体</em></li></ol></li><li><em><strong>之前</strong></em>：我们是否已经在正确的页面上？<ol><li><em>是：没问题！</em></li><li><em>否：加载页面</em></li></ol></li></ol></li><li><p>删除实体</p></li><li><p><strong>结束</strong>（<em>应用状态为空</em>）</p></li></ol><p>现在，如果你一次运行所有测试，每个测试都会利用之前测试的应用状态。如果只运行“修改实体”测试，它会创建所需的一切，然后运行测试本身。</p><p>现在我们既有测试的独立性又有测试的性能！很不错！</p><p>嗯&mldr; 你是否注意到我们需要编写大量代码？<a href=https://github.com/bahmutov/cypress-data-session>cypress-data-session</a> 插件很方便，但存在两个问题：</p><ol><li>有很多与 cypress-data-session 相关的样板代码</li><li>在 E2E 测试中，必须维护许多可能与主应用程序中使用的 API 调用不同步的 API 调用。</li></ol><p>这是一个与 cypress-data-session 相关的样板代码示例（来自 Hasura Console 代码库）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span> <span class=nx>readMetadata</span> <span class=p>}</span> <span class=kr>from</span> <span class=s1>&#39;../services/readMetadata&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span> <span class=nx>deleteHakunaMatataPermission</span> <span class=p>}</span> <span class=kr>from</span> <span class=s1>&#39;../services/deleteHakunaMatataPermission&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Ensure the Action does not have the Permission.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * ATTENTION: if you get the &#34;setup function changed for session...&#34; error, simply close the
</span></span></span><span class=line><span class=cl><span class=cm> * Cypress-controlled browser and re-launch the test file.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=kd>function</span> <span class=nx>hakunaMatataPermissionMustNotExist</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=nx>settingUpApplicationState</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>cy</span><span class=p>.</span><span class=nx>dataSession</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;hakunaMatataPermissionMustNotExist&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Without it, cy.dataSession run the setup function also the very first time, trying to
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// delete a Permission that does not exist
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>init</span><span class=o>:</span> <span class=p>()</span> <span class=o>=&gt;</span> <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Check if the Permission exists
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>validate</span><span class=o>:</span> <span class=p>()</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>Cypress</span><span class=p>.</span><span class=nx>log</span><span class=p>({</span> <span class=nx>message</span><span class=o>:</span> <span class=s1>&#39;**--- Action check: start**&#39;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>readMetadata</span><span class=p>().</span><span class=nx>then</span><span class=p>(</span><span class=nx>response</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>loginAction</span> <span class=o>=</span> <span class=nx>response</span><span class=p>.</span><span class=nx>body</span><span class=p>.</span><span class=nx>actions</span><span class=o>?</span><span class=p>.</span><span class=nx>find</span><span class=p>(</span>
</span></span><span class=line><span class=cl>          <span class=nx>action</span> <span class=o>=&gt;</span> <span class=nx>action</span><span class=p>.</span><span class=nx>name</span> <span class=o>===</span> <span class=s1>&#39;login&#39;</span>
</span></span><span class=line><span class=cl>        <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>loginAction</span> <span class=o>||</span> <span class=o>!</span><span class=nx>loginAction</span><span class=p>.</span><span class=nx>permissions</span><span class=p>)</span> <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>permission</span> <span class=o>=</span> <span class=nx>loginAction</span><span class=p>.</span><span class=nx>permissions</span><span class=p>.</span><span class=nx>find</span><span class=p>(</span>
</span></span><span class=line><span class=cl>          <span class=nx>permission</span> <span class=o>=&gt;</span> <span class=nx>permission</span><span class=p>.</span><span class=nx>role</span> <span class=o>===</span> <span class=s1>&#39;hakuna_matata&#39;</span>
</span></span><span class=line><span class=cl>        <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Returns true if the permission does not exist
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=o>!</span><span class=nx>permission</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>preSetup</span><span class=o>:</span> <span class=p>()</span> <span class=o>=&gt;</span>
</span></span><span class=line><span class=cl>      <span class=nx>Cypress</span><span class=p>.</span><span class=nx>log</span><span class=p>({</span> <span class=nx>message</span><span class=o>:</span> <span class=s1>&#39;**--- The permission must be deleted**&#39;</span> <span class=p>}),</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Delete the Permission
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>setup</span><span class=o>:</span> <span class=p>()</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>deleteHakunaMatataPermission</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nx>settingUpApplicationState</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Ensure the UI read the latest data if it were previously loaded
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>cy</span><span class=p>.</span><span class=nx>reload</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>以下是用于创建实体的 API 调用示例（来自 Hasura Console 代码库）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Create the Action straight on the server.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=kd>function</span> <span class=nx>createLoginAction() {</span>
</span></span><span class=line><span class=cl>  <span class=nx>Cypress</span><span class=p>.</span><span class=nx>log</span><span class=p>({</span> <span class=nx>message</span><span class=o>:</span> <span class=s1>&#39;**--- Action creation: start**&#39;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>cy</span><span class=p>.</span><span class=nx>request</span><span class=p>(</span><span class=s1>&#39;POST&#39;</span><span class=p>,</span> <span class=s1>&#39;http://localhost:8080/v1/metadata&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>type</span><span class=o>:</span> <span class=s1>&#39;bulk&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>source</span><span class=o>:</span> <span class=s1>&#39;default&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>args</span><span class=o>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>type</span><span class=o>:</span> <span class=s1>&#39;set_custom_types&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>args</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nx>scalars</span><span class=o>:</span> <span class=p>[],</span>
</span></span><span class=line><span class=cl>          <span class=nx>input_objects</span><span class=o>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>              <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;SampleInput&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=nx>fields</span><span class=o>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span> <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;username&#39;</span><span class=p>,</span> <span class=kr>type</span><span class=o>:</span> <span class=s1>&#39;String!&#39;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span> <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;password&#39;</span><span class=p>,</span> <span class=kr>type</span><span class=o>:</span> <span class=s1>&#39;String!&#39;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>              <span class=p>],</span>
</span></span><span class=line><span class=cl>            <span class=p>},</span>
</span></span><span class=line><span class=cl>          <span class=p>],</span>
</span></span><span class=line><span class=cl>          <span class=nx>objects</span><span class=o>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>              <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;SampleOutput&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=nx>fields</span><span class=o>:</span> <span class=p>[{</span> <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;accessToken&#39;</span><span class=p>,</span> <span class=kr>type</span><span class=o>:</span> <span class=s1>&#39;String!&#39;</span> <span class=p>}],</span>
</span></span><span class=line><span class=cl>            <span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>              <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;LoginResponse&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=nx>description</span>: <span class=kt>null</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=nx>fields</span><span class=o>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                  <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;accessToken&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=kr>type</span><span class=o>:</span> <span class=s1>&#39;String!&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=nx>description</span>: <span class=kt>null</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=p>},</span>
</span></span><span class=line><span class=cl>              <span class=p>],</span>
</span></span><span class=line><span class=cl>            <span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>              <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;AddResult&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=nx>fields</span><span class=o>:</span> <span class=p>[{</span> <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;sum&#39;</span><span class=p>,</span> <span class=kr>type</span><span class=o>:</span> <span class=s1>&#39;Int&#39;</span> <span class=p>}],</span>
</span></span><span class=line><span class=cl>            <span class=p>},</span>
</span></span><span class=line><span class=cl>          <span class=p>],</span>
</span></span><span class=line><span class=cl>          <span class=nx>enums</span><span class=o>:</span> <span class=p>[],</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>      <span class=p>},</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>type</span><span class=o>:</span> <span class=s1>&#39;create_action&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>args</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;login&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=nx>definition</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>arguments</span><span class=o>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>              <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;username&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=kr>type</span><span class=o>:</span> <span class=s1>&#39;String!&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>description</span>: <span class=kt>null</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=p>},</span>
</span></span><span class=line><span class=cl>              <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;password&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=kr>type</span><span class=o>:</span> <span class=s1>&#39;String!&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>description</span>: <span class=kt>null</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=p>],</span>
</span></span><span class=line><span class=cl>            <span class=nx>kind</span><span class=o>:</span> <span class=s1>&#39;synchronous&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>output_type</span><span class=o>:</span> <span class=s1>&#39;LoginResponse&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>handler</span><span class=o>:</span> <span class=s1>&#39;https://hasura-actions-demo.glitch.me/login&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=kr>type</span><span class=o>:</span> <span class=s1>&#39;mutation&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>headers</span><span class=o>:</span> <span class=p>[],</span>
</span></span><span class=line><span class=cl>            <span class=nx>timeout</span>: <span class=kt>25</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>request_transform</span>: <span class=kt>null</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=p>},</span>
</span></span><span class=line><span class=cl>          <span class=nx>comment</span>: <span class=kt>null</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>      <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>],</span>
</span></span><span class=line><span class=cl>  <span class=p>}).</span><span class=nx>then</span><span class=p>(()</span> <span class=o>=&gt;</span> <span class=nx>Cypress</span><span class=p>.</span><span class=nx>log</span><span class=p>({</span> <span class=nx>message</span><span class=o>:</span> <span class=s1>&#39;**--- Action creation: end**&#39;</span> <span class=p>}));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>因此，拥有独立的测试是至关重要的，但也伴随着一些成本。</p><p>这就是为什么，针对这个具体问题，我选择了最后一种选择&mldr;</p><h4 id=3---进行一次全面的端到端测试>3 - 进行一次全面的端到端测试<a hidden class=anchor aria-hidden=true href=#3---进行一次全面的端到端测试>#</a></h4><p>优点：可以减少很多样板文件。</p><p>缺点：与测试一起工作变得更慢了（你不能再仅运行第三个测试了）</p><p>与我们需要编写的样板和需要维护的代码相比，将它们统一起来是值得的。毕竟，我正在处理的特定 CRUD 流程大约需要 20 秒。</p><ol><li>开始 (<em>应用程序状态为空</em>)</li><li>测试：CRUD<ol><li><em><strong>之前</strong></em>*：如果存在实体，则删除它（应用程序状态为空）*</li><li><em><strong>之前</strong></em>*：加载页面*</li><li>创建实体</li><li>修改实体</li><li>删除实体</li><li><em><strong>之后</strong></em>*：如果存在实体，则删除它（应用程序状态为空）*</li></ol></li><li>结束 (<em>应用程序状态为空</em>)</li></ol><p>同时，这也使得 cypress-data-session 变得无用。因此，少了一个需要保持更新的依赖。</p><h4 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h4><p>处理端到端测试很困难。处理真实数据、清除真实应用程序状态等都是有成本的。我知道端到端测试是唯一能够提供完整信心的测试，但作为一名前端工程师（请记住，我不是 QA 工程师），我更愿意使用无需服务器的测试。</p><h4 id=相关章节>相关章节<a hidden class=anchor aria-hidden=true href=#相关章节>#</a></h4><ul><li>🔗 <a href=/sections/beginners/top-to-bottom-approach.zh.md>从金字塔的顶端着手构建测试！</a></li><li>🔗 <a href=/sections/generic-best-practices/use-your-testing-tool-as-your-primary-development-tool.zh.md>把你的测试工具当作主要的开发工具来使用</a><br><br></li></ul><p><em>由 <a href=https://github.com/NoriSte>NoriSte</a> 在 <a href=https://dev.to/noriste/decouple-the-back-end-and-front-end-test-through-contract-testing-112k>dev.to</a>上进行了跨发表。</em></p><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><ul><li>UI 测试最佳实践项目:<a href=https://github.com/NoriSte/ui-testing-best-practices>https://github.com/NoriSte/ui-testing-best-practices</a></li><li>UI 测试最佳实践项目中文翻译:<a href=https://github.com/naodeng/ui-testing-best-practices>https://github.com/naodeng/ui-testing-best-practices</a></li></ul><hr><p>欢迎关注软件测试同学的公众号“<strong>软件测试同学</strong>”，原创 QA 技术文章第一时间推送。</p><center><img src="https://cdn.jsdelivr.net/gh/naodeng/blogimg@master/uPic/2023112015'QR Code for 公众号.jpg" style=width:100px></center></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://naodeng.com.cn/zh/posts/performance-testing/k6-tutorial-common-functions-1-http-request-metrics-and-checks/><span class=title>« 上一页</span><br><span>K6 性能测试教程：常用功能（1）- HTTP 请求，指标和检查</span>
</a><a class=next href=https://naodeng.com.cn/zh/posts/ui-automation-testing/ui-testing-best-practice-testing-strategy-1-component-tests-vs-ui-integration-tests-vs-e2e-tests/><span class=title>下一页 »</span><br><span>UI 测试最佳实践的测试策略（一）：组件测试 vs（UI）集成测试 vs E2E 测试</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share UI 测试最佳实践的测试策略（二）：什么样的测试策略才更合理 on x" href="https://x.com/intent/tweet/?text=UI%20%e6%b5%8b%e8%af%95%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5%e7%9a%84%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5%e6%89%8d%e6%9b%b4%e5%90%88%e7%90%86&amp;url=https%3a%2f%2fnaodeng.com.cn%2fzh%2fposts%2fui-automation-testing%2fui-testing-best-practice-testing-strategy-2-more-reasonable-testing-strategy-for-ui-testing%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share UI 测试最佳实践的测试策略（二）：什么样的测试策略才更合理 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fnaodeng.com.cn%2fzh%2fposts%2fui-automation-testing%2fui-testing-best-practice-testing-strategy-2-more-reasonable-testing-strategy-for-ui-testing%2f&amp;title=UI%20%e6%b5%8b%e8%af%95%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5%e7%9a%84%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5%e6%89%8d%e6%9b%b4%e5%90%88%e7%90%86&amp;summary=UI%20%e6%b5%8b%e8%af%95%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5%e7%9a%84%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5%e6%89%8d%e6%9b%b4%e5%90%88%e7%90%86&amp;source=https%3a%2f%2fnaodeng.com.cn%2fzh%2fposts%2fui-automation-testing%2fui-testing-best-practice-testing-strategy-2-more-reasonable-testing-strategy-for-ui-testing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share UI 测试最佳实践的测试策略（二）：什么样的测试策略才更合理 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fnaodeng.com.cn%2fzh%2fposts%2fui-automation-testing%2fui-testing-best-practice-testing-strategy-2-more-reasonable-testing-strategy-for-ui-testing%2f&title=UI%20%e6%b5%8b%e8%af%95%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5%e7%9a%84%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5%e6%89%8d%e6%9b%b4%e5%90%88%e7%90%86"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share UI 测试最佳实践的测试策略（二）：什么样的测试策略才更合理 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fnaodeng.com.cn%2fzh%2fposts%2fui-automation-testing%2fui-testing-best-practice-testing-strategy-2-more-reasonable-testing-strategy-for-ui-testing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share UI 测试最佳实践的测试策略（二）：什么样的测试策略才更合理 on whatsapp" href="https://api.whatsapp.com/send?text=UI%20%e6%b5%8b%e8%af%95%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5%e7%9a%84%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5%e6%89%8d%e6%9b%b4%e5%90%88%e7%90%86%20-%20https%3a%2f%2fnaodeng.com.cn%2fzh%2fposts%2fui-automation-testing%2fui-testing-best-practice-testing-strategy-2-more-reasonable-testing-strategy-for-ui-testing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share UI 测试最佳实践的测试策略（二）：什么样的测试策略才更合理 on telegram" href="https://telegram.me/share/url?text=UI%20%e6%b5%8b%e8%af%95%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5%e7%9a%84%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5%e6%89%8d%e6%9b%b4%e5%90%88%e7%90%86&amp;url=https%3a%2f%2fnaodeng.com.cn%2fzh%2fposts%2fui-automation-testing%2fui-testing-best-practice-testing-strategy-2-more-reasonable-testing-strategy-for-ui-testing%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share UI 测试最佳实践的测试策略（二）：什么样的测试策略才更合理 on ycombinator" href="https://news.ycombinator.com/submitlink?t=UI%20%e6%b5%8b%e8%af%95%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5%e7%9a%84%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5%e6%89%8d%e6%9b%b4%e5%90%88%e7%90%86&u=https%3a%2f%2fnaodeng.com.cn%2fzh%2fposts%2fui-automation-testing%2fui-testing-best-practice-testing-strategy-2-more-reasonable-testing-strategy-for-ui-testing%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=naodeng/naodeng.tech data-repo-id=R_kgDOHntNtg data-category="Show and tell" data-category-id=DIC_kwDOHntNts4Cavst data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=light data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://naodeng.com.cn/zh/>软件测试同学</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>